# HTTP

본문의 내용들은 [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#) 강의를 보고 정리하였습니다.

아래 내용은 제가 공부할 수 있도록 정리한 것이라 이해하기 어려울 수 있으므로 꼭 위 강의를 들어보시는 것을 추천드립니다.

<br>
<br>
<br>

## IP(Internet Protocol)의 역할

- 지정한 IP 주소에 데이터를 전달한다.
- 통신 단위인 패킷을 전달한다.

## IP 패킷의 목적

![ip](https://user-images.githubusercontent.com/55525868/158522136-8eb1318f-d47e-46f0-8b37-785872441e0c.PNG)

- IP 패킷에는 출발지 IP와 목적지 IP가 있다.
- 출발지 IP와 목적지 IP를 통해 데이터를 전송한다.

> 패킷 : package와 bucket의 합친 말로, 네트워크상에서 전송하는 데이터의 형식화된 블록이다.
참고: https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%8C%A8%ED%82%B7

## IP 프로토콜의 한계

- 비연결성
    - 만약 패킷을 받을 상대가 인터넷이 끊겨도 즉, 서비스 불능 상태여도 패킷은 그대로 전송
- 비신뢰성
    - 패킷을 전송했는데 중간에 패킷이 사라지거나 패킷이 순서대로 오지 않은 경우
- 프로그램 구분
    - 한 IP로 여러 애플리케이션을 돌릴 경우

**이러한 IP 프로토콜의 한계를 TCP가 해결**

<br>
<br>
<br>

## 인터넷 프로토콜 4계층

![stack](https://user-images.githubusercontent.com/55525868/158523007-ce2b9ad7-e082-4fdf-8079-9fcfe0ddc7e0.PNG)

참고 : https://hahahoho5915.tistory.com/15

- 1계층 `네트워크 인터페이스 계층` : 물리적인 주소로 MAC을 사용하고 LAN, 패킷망 등에 사용
- 2계층 `인터넷 계층` : 통신 노드간의 IP패킷을 전송하는 기능과 라우팅 기능을 담당
- 3계층 `전송 계층` : 통신 노드간의 연결을 제어하고, 신뢰성 있는 데이터 전송을 담당
- 4계층 `어플리케이션 계층` : TCP/UDP 기반의 응용 프로그램을 구현할 때 사용

**인터넷 계층인 `IP` 위에 전송 계층인 `TCP`를 씌움으로서 IP의 한계를 극복**

![tcp2](https://user-images.githubusercontent.com/55525868/158523906-c81513d4-06a9-4572-b2f2-77dd0f84252b.PNG)

1. 만약 펜팔친구에게 `잘 지내니`라는 메시지를 보낸다고 가정하자. 이 때 IP 패킷을 두 개로 나누어서 보낸다. `잘` 패킷과 `지내니` 패킷

> IP는 순서가 보장되지 않기 때문에 `지내니 잘`로 메시지가 갈 수도 있습니다.

2. 메시지를 보낼 때 어플리케이션 계층인 `Socket 라이브러리`를 통해 데이터를 전송한다.

3. 그리고나서 OS 계층에서 `IP 패킷`에다가 `TCP`를 씌운다.

4. LAN 카드를 통해 패킷을 서버로 전송합니다.

## TCP

![tcp3](https://user-images.githubusercontent.com/55525868/159257091-0f6d2e26-3b3a-4d77-be60-8a596ad85372.PNG)

- TCP는 IP패킷 안에 TCP 정보가 들어간다.
- TCP에는 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 등의 정보가 들어있다.

## TCP 특징

- TCP란 전송 제어 프로토콜(Transmissioni Control Protocol)
- 연결지향 - TCP 3 way handshake
- 데이터 전달 보증
    - 중간에 패킷이 누락되어도 알 수 있음
- 순서 보장
- 신뢰성 있는 프로토콜 -> 대부분 TCP를 사용

### TCP 3 way handshake

![tcp4](https://user-images.githubusercontent.com/55525868/159257095-6e66b076-7381-41dd-8ccb-4aa7f692451c.PNG)

1. 클라이언트 -> 서버로 `SYN`이라는 메시지를 보내서 접속을 요청한다.
2. 서버 -> 클라이언트로 `ACK`라는 메시지를 통해 접속 요청에 대한 응답을 해주고 다시 서버쪽에서 요청을 하기 위해 `SYN`을 보낸다. 즉, 이때는 `SYN+ACK` 이렇게 메시지를 보냅니다.
3. 클라이언트 -> 서버로 서버에 대한 요청을 응답해주기 위한 `ACK` 메시지를 보낸다.

위 세 과정을 하게 되면 클라이언트와 서버간에 신뢰할 수 있게 되어 연결을 할 수 있게 된다.  
이것이 **3 way handshake**

### 3 way handshake 의 장점

예를 들어, 클라이언트쪽에서 `SYN`을 보냈는데 서버쪽에서 `ACK`를 못받으면 문제가 있는 것으로 판별할 수 있음.

기존에 `IP 프로토콜`만 있을 때는 `비연결성`이기 때문에 클라이언트쪽에서 패킷을 보내도 정상적으로 데이터가 전송이 되었는지 누락이 되었는지 알 수 없었지만 `TCP 프로토콜`이 생기면서 이러한 점을 보완할 수 있음.
  
> 여기서 알아야 할 점은 3 way handshake는 물리적으로 서로 연결된 것이 아니라 논리적으로 연결된 것을 말한다.
> 즉, "아, 서로 연결이 잘됐나 보다~" 하고 판단을 내린 가상 연결을 의미합니다.

<br>
<br>

### 데이터 전달 보증

1. 클라이언트에서 서버로 데이터를 전송
2. 서버에서 클라이언트로 데이터를 잘 받았다고 전송

위 과정이 이루어져야 신뢰성 있는 통신이 가능합니다.  
만약 데이터를 전송했는데 그에 대한 응답이 없으면 정상적으로 연결이 되지 않은 것임

  

### 순서 보장

1. 클라이언트에서 서버로 패킷1, 패킷2, 패킷3 ... 순서로 전송한다.
2. 만약 서버에서 패킷1, 패킷3, 패킷2 ... 순서로 받았다면 순서가 맞지 않으므로 서버에서 클라이언트로 다시 패킷2부터 보내라고 요청 -> ✨ 순서가 보장!!

이렇게 순서가 보장이 될 수 있는 이유는 TCP의 전송 제어, 검증 등의 정보 때문에 가능

그래서 TCP는 신뢰성 있는 프로토콜이라고도 불림

<br>
<br>
<br>

## UDP

UDP는 TCP과 같은 전송 계층에 있음

## UDP 특징

- 사용자 데이터그램 프로토콜 (User Datagram Protocol)
- 기능이 거의 없음
- 연결지향 - TCP 3 way handshake X
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서를 보장하지 않지만 그 만큼 속도가 빠르다는 장점이 있음

이는 즉, IP와 거의 같지만 여기에 PORT와 체크섬(검증)이 추가됨

IP는 한 IP에 여러 애플리케이션이 돌아갈 경우에 패킷을 구분할 수가 없는 것이 IP의 한계

만약 여기에 PORT가 추가되면 한 IP에 각각의 애플리케이션마다 패킷 구분이 가능

<br>

**결국 TCP와 UDP의 결정적 차이는 '속도'**

TCP는 3 way handshake라는 과정을 거쳐야 하기 때문에 속도가 UDP보다 느릴 수 밖에 없음

UDP는 그런 과정이 없는 하얀 도화지이기 때문에 속도가 더 빠름

<br>
<br>
<br>

## PORT

만약 내 pc 에 여러 어플리케이션을 돌리고 있다고 가정해보자. (게임, 화상 통화, 웹 브라우저 요청 ...)  
이 경우에는 여러 서버랑 통신하게 된다.  
여기서 서버쪽에서 각각의 어플리케이션의 패킷들이 내 pc로 올텐데 ❗ 이 때!! 패킷들이 게임 패킷인지, 화상통화 패킷인지, 웹 브라우저 응답 패킷인지 구분을 할 수가 없다.

그래서 한 IP안에 여러 어플리케이션 패킷을 구분 지을 수 있도록 'PORT' 를 사용한다.

<br>

즉, IP는 어떤 출발지와 목적지를 구분하기 위해 출발지 IP, 목적지 IP가 있고,

PORT는 한 IP 내에 여러 어플리케이션이 돌고 있을 때 각 패킷을 구분짓기 위해 사용한다.

> 게임: 8000포트
> 화상 통화: 10000포트
> 웹 브라우저 요청: 8080포트

- PORT는 0 ~ 65535 할당 가능
- 0 ~ 1023 은 잘 알려진 포트이므로 사용하지 않는 것이 좋다.
    - FTP : 20, 21
    - TELNET : 23
    - HTTP : 80
    - HTTPS : 443

> IP와 PORT를 구분하는 예시
> 아파트가 있을 때 한 아파트는 IP,
> 한 아파트의 몇동, 몇호는 PORT
  
<br>

## DNS

내 PC와 상대 PC를 구분짓기 위해 출발지 IP와 목적지 IP 라는 것을 사용했다.  

하지만 IP는 `100.100.100.1` 처럼 숫자로 되어 있기 때문에 외우기가 쉽지 않다.

<br>

그래서 사람들이 외우기 쉽게 하기 위해 IP에 이름을 짓는다. 이것이 바로 `도메인명`

예를 들어 구글이면 구글 사이트가 만약 IP가 `123.456.673.2` 이렇게 되어 있으면 사람들이 굉장히 구글 사이트에 들어가기가 힘들 것입니다.  

하지만 구글 이라는 타이틀로 도메인을 설정하면 사람들이 쉽게 접근할 수 있다. (ex. [www.google.com](http://www.google.com))

또 한 가지 `DNS 서버`를 사용하게 되면 다음과 같은 key, value 형태로 값이 저장하게 되는데,

|도메인명|IP|
|:---:|:---:|
|google.com|123.456.673.2|

- 여기서 만약 구글의 IP가 변경된다고 해도 사용자는 그대로 도메인명인 `google.com`을 사용하면 된다.
- 왜냐하면 value인 IP만 변경하면 되므로 도메인명은 그대로 사용

<br>
<br>
<br>
  
## 💨 여기까지 정리해보기.

### IP (Internet Protocol address)

- IP는 각 컴퓨터의 주소이고, 역할은 상대 IP 주소로 데이터를 전송한다.
- 다만, IP는 비신뢰성이고, 비연결성이고, 순서가 없고, 프로그램 구분을 할 수가 없다.

### TCP (Transmission Control Protocol)

- 위 IP의 한계를 보완한 것이 TCP 프로토콜
- TCP는 신뢰성 있고(데이터 전달 보장), 연결지향인 3 way handshake를 사용하고, 순서도 보장
- 다만, 3 way handshake 통신으로 인해 속도가 느림

### UDP (User Datagram Protocol)

- TCP와 거의 반대로 기능이 거의 없고, 3 way handshake를 사용하지 않고, 순서를 보장하지 않고, 신뢰성이 없다.
- 다만, 3 way handshake를 사용하지 않아 TCP보다 속도가 빠르다.
- 또한 TCP와 다르게 사용자가 직접 커스터마이징할 수 있다.

### PORT

- 사용하는 애플리케이션을 구분하기 위해서 사용

### DNS

- IP는 외우기 어렵고 변경되면 골치아픈데 그러한 문제를 해결해주는 것이 `DNS`이다.

<br>
<br>
<br>

## URI

- URI(Uniform Resource Identifier)는 로케이터(Locator), 이름(Name) 또는 둘 다 추가로 분류

> URI는 통합 자원 식별자의 줄임말이다.
> 결론은 URI라는 개념은 어떤 형식이 있다기 보다는 특정 자원을 식별하는 문자열을 의미한다. 그래서 URL이 아니고 URN도 아니면 그냥 URI가 된다.
> 참고 : https://hanamon.kr/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EB%B3%B8-url-uri-urn-%EC%B0%A8%EC%9D%B4%EC%A0%90/
  
- URI 안에 URL과 URN이 있다.  
- **URL**은 `https://www.naver.com` 처럼 웹 브라우저에 주소 적는 것이 URL
    - Locator, 리소스가 있는 위치 조정
- **URN**은 `urn:example:animal:ferret:nose` 처럼 주소처럼 이름을 부여하는 것이 URN
    - URN의 단점은 중간에 이름을 넣으면 찾기 매우 어려움 -> 거의 URL만 사용

URL과 URN의 차이점은 URL은 위치(Locator)로서 변할 수 있지만 이름(Name)은 변하지 않는다.

<br>

### ❕ query string

쿼리 스트링은 URL에 **파라미터 정보를 받기 위해서 사용**

즉, GET 방식에서 사용되고 `key=value` 형태로 되어있다.  

그리고 쿼리 스트링을 사용할 때는 `?`로 시작을 해서 여러 파라미터를 받기 위해서는 `&`로 구분한다.

- ex) https://www.google.com/search?q=bye&sxsrf=APq
- 여기서 ? 뒤부터 쿼리 스트링이며,
- key는 q, sxsrf 그리고 value는 bye, Apq

그리고 쿼리 스트링에서 `string`인 이유는 파라미터 타입이 모두 문자열이기 때문.

<br>
<br>
<br>

## 웹 브라우저 주소를 검색했을 때 무슨 일이 벌어질까?

면접에서도 나올만한 질문인 `https://www.naver.com` 이 주소를 쳤을 때 어떤 일이 벌어질까요?

<br>  

1. 가장 먼저 DNS서버를 조회한다. ([www.naver.com](http://www.naver.com))

2. DNS를 조회해서 도메인명이 `www.naver.com`인 IP와 PORT를 찾아낸다.

3. **HTTP 요청 메시지를 생성**하고 TCP/IP 패킷을 씌운다. 이 패킷에는 IP, PORT 정보가 들어있고 전송데이터에는 HTTP 요청 메시지가 포함하고 있다.

4. HTTP 요청 메시지가 포함된 요청 패킷을 `네이버서버`로 보낸다.

5. 서버는 받은 패킷 안에 있는 **HTTP 요청 메시지를 해석**해서 데이터를 찾는다. (HTTP 메소드, 쿼리스트링, host 등등..)

6. 해석한 후에 네이버 서버에서 **HTTP 응답 메시지를 생성**해서 응답 패킷에 담아서 클라이언트로 보낸다.

7. 클라이언트는 HTTP 응답 메시지를 보면 Body안에 데이터를 `Content-Type`에 따라 웹 브라우저에 렌더링되어 화면에 보여지게 된다.

### HTTP 요청 메시지

```
GET /search?name=minsu&lan=ko HTTP/1.1
Host: www.naver.com
```

> Host란?
> IP를 가지고 있고 양방향 통신이 가능한 컴퓨터를 말한다.
> ex) www.google.com
> 참고: https://hihighlinux.tistory.com/73

### HTTP 응답 메시지

```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
    <body>...</body>
</html>
```

<br>
<br>
<br>

## HTTP

HTTP(HyperText Transfer Protocol)는 하이퍼 텍스트, 즉 문서 간에 정보를 주고 받을 수 있는 프로토콜

현재는 모든 것을 HTTP 프로토콜에 담아서 전송한다. (html, text, json, xml, image, 오디오, 영상 ...)  

또한 HTTP 에도 버전이 있는데 가장 많이 사용하는 버전이 `HTTP/1.1`  
따라서 `HTTP/1.1` 을 공부하는 것이 중요

> 👌 잠깐!
> TCP기반으로 사용되는 어플리케이션 계층에서 사용하는 HTTP 버전은 `HTTP/1.1`, `HTTP/2`를 사용하고,
> UDP기반은 `HTTP/3` 버전을 사용한다.

<br>

## HTTP 특징

- 클라이언트 - 서버 구조
    - 클라이언트가 서버에 요청을 하고, 서버는 요청에 대한 응답하는 구조
- Stateless(무상태) Protocol, 비연결성
- HTTP 메시지를 통해 통신
- 단순하고, 확장 가능

### 무상태 (Stateless)

- Stateless란, 서버가 클라이언트의 상태를 보존하지 않는다는 뜻
- 반대로 Stateful은, 서버가 클라이언트의 상태를 보존한다는 뜻

![UI drawio (2)](https://user-images.githubusercontent.com/55525868/158754777-ff011bfe-c3f1-44e1-8c31-75c094ddc2ae.png)

#### Stateful인 경우

- 클라이언트와 서버1과 서로 통신하고 있을 때 에러가 발생하면 어떻게 될까?

서버1은 클라이언트의 상태를 유지한다. **예를 들어, 어떤 상품을 100만원에 구매한다고 하면 그 상품을 구매하기 위한 필요한 정보들을 서버1이 가지고 있다는 의미**  
(필요한 정보: 상품명, 상품가격, 결제방법 등..)

만약에 서버1이 다운된다면 서버1은 클라이언트의 정보를 다 잃게 된다.

그러면 클라이언트는 구매하려던 상품을 처음부터 다시 구매하기를 해야한다. (불편.. 😢)

#### Stateless인 경우

- 하지만 Stateless인 경우에는 어떻게 될까?

서버1은 클라이언트의 상태를 유지하지 않는다. **예를 들어, 어떤 상품을 100만원에 구매한다고 하면 그 정보를 서버1은 유지하지 않는다. 따라서 클라이언트는 처음 요청할 때 필요한 데이터를 모두 넘겨야 한다.**  
ex)아이패드 신형을 네이버페이로 100만원에 구매하겠습니다. (구체적 👍)

만약에 서버1이 다운된다해도 클라이언트 입장에서는 전혀 문제가 없다.

그 이유는, 서버2라는 대체 서버가 존재하기 때문입니다. Stateful도 대체 서버가 존재하는데 왜 Stateless만 문제가 없을까?

Stateless의 경우 클라이언트는 처음 요청할 때 필요한 데이터를 모두 넘겨야 한다고 했다. 그래서 데이터 안에 필요한 정보가 다 들어있기때문에 다른 서버와 통신해도 전혀 문제가 발생하지 않는다.

> 그래서 Stateless는 서버를 scale-out, 무한히 확장가능한 것입니다.
  
### Stateless의 한계

하지만 모든 것을 Stateless하게 설계할 수는 없다.

예를 들어, 로그인이 대표적인 예!

로그인을 했을 때 상태를 유지하지 않는다면 다른 페이지로 요청했을 때 또 로그인을 해야한다.

그래서 이를 해결하기 위해 나온 것이 `쿠키와 세션`
  
또 한 가지의 단점은,

Stateless는 필요한 데이터를 모두 넘겨야하기 때문에 데이터를 많이 보낸다.

> 결론은 애플리케이션을 설계할 때는 최대한 무상태로 설계하고, 어쩔 수 없는 경우에만 상태를 유지한다.

<br>

## 비연결성 (connectionless)

![UI drawio (3)](https://user-images.githubusercontent.com/55525868/158755016-ed57fa0d-338f-4d49-bb9f-7b2fcf43eb93.png)

### 연결성

비연결성에 대해 알아보기 전에 먼저 '연결성 모델'에 대해 알아보자.

1. 클라이언트A는 서버1과 통신한다.
2. 클라이언트B도 서버1과 통신한다.
3. 클라이언트C도 서버1과 통신하고 있을 때 클라이언트A와 클라이언트B는 서버1과 계속 연결을 유지하고 있다. (통신을 계속 하고 있다는 의미)

이 때 문제점은 클라이언트C와 서버1과 통신하고 있을 때 필요하지 않는 통신(클라이언트A, 클라이언트B)도 계속 유지하고 있기 때문에 서버1 입장에서는 자원을 계속 소비하게 된다.

클라이언트가 적을 때는 상관없지만 클라이언트가 갑자기 급증하게 된다면 서버에 과부하가 걸려서 서버가 다운될 것이다.

---

### 비연결성

반면에 비연결성은 간단하다.

1. 클라이언트A와 서버1과 통신하고 연결을 끊는다.
2. 클라이언트B와 서버1과 통신하고 연결을 끊는다.
3. 클라이언트C와 서버1과 통신하고 연결을 끊는다.

각각의 클라이언트가 서버1과 통신하고 바로바로 연결을 끊기 때문에 낭비되는 서버 자원을 줄일 수 있다.

**비연결성: 요청이 필요할 때마다 그때그때 연결해서 바로 끊는 형태**

### 결론

HTTP의 큰 장점인 비연결성은 클라이언트가 요청하고 서버가 응답하면 연결을 끊기 때문에 서버 자원을 효율적으로 사용할 수 있고, 특정 시간동안 수천명의 사용자가 서비스를 사용해도 실제로 동시에 요청하는 건수는 수십개 밖에 안되므로 비연결성 모델을 사용하는 것이 좋다.

### 비연결성의 단점

HTTP 통신은 대부분이 TCP/IP를 사용한다. 하지만 TCP/IP는 바로 `3 way handshake`를 사용한다. 이는 즉 신뢰성 있는 데이터 전달을 위해 **시간이 추가**된다는 의미

그리고 또 다른 단점은 많은 자원을 다시 다운로드해야 된다.

웹 브라우저를 요청하게 되면 html, css, js, image... 등등 필요한 자원을 다운로드하게 되는데 그러면 요청할 때마다 수많은 자원들을 다시 다운로드해야하는 단점이 있다.

- 하지만 지금은 HTTP 지속 연결(Persistent Connections)로 문제를 해결함.
- 그리고 HTTP/2, HTTP/3로 이러한 단점들이 많이 보완되었음.

### HTTP 지속 연결

자, HTTP는 TCP/IP 기반으로 돌아간다. 그리고 TCP/IP는 `3-way-hankshake`를 사용한다. (이것만 기억하고 다음을 읽어보자.)

HTTP는 문서 간에 정보를 주고받을 수 있는 프로토콜이라고 했다. (현재는 모든 정보를 HTTP를 통해서 주고받는다.)

(가정) HTTP를 통해 html 자원을 받고싶다면 시간이 얼마나 걸릴까?

먼저 TCP/IP의 `3-way-hankshake로 연결확인`하고 `html 요청/응답 확인`하고 `TCP/IP 연결을 종료`한다. 이게 하나의 리소스(html)를 다운받는데 일련의 과정인데 이 과정을 0.3초 걸린다고 가정해보자.
  
![UI drawio (4)](https://user-images.githubusercontent.com/55525868/158779319-e73b1507-6ba9-4756-9d91-f2157bc4f135.png)

그러면 만약에 필요한 리소스가 html, css ,js 총 3개라고 한다면 `0.3 * 3 = 0.9초`가 걸린다.

하지만 HTTP 지속 연결을 사용한다면 시간이 더 단축된다.

![UI drawio (5)](https://user-images.githubusercontent.com/55525868/158780043-5fc7ea7b-57c3-4d33-9ce6-62832b6578e9.png)

차이점은

HTTP 지속 연결을 사용하지 않는다면 일련의 과정마다 매번 연결하고 종료를 해줘야 했지만

HTTP 지속 연결을 사용하면 `한번 연결`하고 `리소스(html,css,js) 요청/응답받고` `한번 종료`시키기 때문에 시간이 훨씬 단축된다.

### 💫 참고!!!

#### 서버개발자들은 반드시 Stateless를 꼭 기억하자

- 같은 시간에 발생하는 대용량 트래픽
- 이벤트가 생길 때 사용자가 급증할 때

**이를 해결하기 위해서는 어떻게든 머리를 짜서 반드시 Stateless하게 설계를 해야 한다.**

> 간단한 해결법은 일단은 정적 페이지하나 생성해서 일단 그 페이지를 보게 한 다음에 이벤트 페이지로 들어가게 만드는 방법

## HTTP 메시지 구조

![http](https://user-images.githubusercontent.com/55525868/144202391-d37c87e6-0bbf-44e7-8673-2b88628b601c.PNG)

### HTTP 요청 메시지

```
GET /search?name=minsu&lan=ko HTTP/1.1 -> 시작 라인
Host: www.naver.com -> 헤더
    -> 공백 라인
```

### HTTP 응답 메시지

```
HTTP/1.1 200 OK -> 시작 라인
Content-Type: text/html;charset=UTF-8
Content-Length: 3423 -> 헤더
    -> 공백 라인
<html>
    <body>...</body>
</html> -> 메시지 바디
```

<br>
<br>
<br>

## URI 설계

API를 만들 때는 URI 설계가 굉장히 중요하다.

여기서 URI를 잘 설계하기 위해서는 알아야 하는 것이 **리소스 식별**이다.

그리고 이 리소스에 대한 동작을 담당하는 **행위**가 있다.

이 부분은 [REST API](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)를 참고할 것!!

너무 좋은 글이고, 간단하게 REST API는 리소스와 행위를 분리해서 **리소스를 식별**하고 **식별한 리소스에 대한 행위(CRUD)를 적용**한다.

또한 REST API는 HTTP 프로토콜을 그대로 활용한 것으로 별도의 인프라를 구성할 필요가 없다.

- [restfulapi_naming](https://restfulapi.net/resource-naming/)도 보면 좋을 것 같다.

## HTTP 메소드

- GET, POST, PATCH, PUT, DELETE에 대해 알아보자.
- 참고: https://developer.mozilla.org/ko/docs/Web/HTTP/Methods
- 멱등: 같은 데이터를 한번 호출하든 100번 호출하든 결과가 똑같다.

> 멱등이 필요한 이유
> 서버가 timeout으로 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는지 -> 자동 복수 메커니즘에 필요하다.

### GET

- 특정한 리소스를 가져오도록 요청한다.
- GET 요청은 데이터를 가져올 때만 사용해야 한다.
- 서버에 전달하고 싶은 데이터는 `query string`을 통해 전달
- GET 요청에 메시지 바디에 데이터를 담을 수도 있지만 이는 권장하지 않으므로 사용하지 말자.
- 캐시가 가능하다.
- 멱등하다.

```json
GET /members/100 HTTP/1.1
Host: example.com
```

### POST

- 요청 데이터 처리
- `메시지 바디`를 통해 서버로 요청 데이터 전달
    - 서버는 요청 데이터를 처리
    - 메시지 바디 타입(html, json..)은 `Content-Type`에 나타낸다.
- **멱등 아니다.**
    - 결제를 생각해보면 한번 호출하고 두번 호출하는 것은 다르다.

```json
POST /members HTTP/1.1
Host: example.com
Content-type: application/json

{
    "name": "minsu",
    "age": 30
}
```

### POST 기능

1. 새 리소스 생성(등록)
    - POST는 리소스의 URI를 모르지만 서버가 새로 등록된 리소스 URI를 생성해준다.
    - 이렇게 서버가 리소스 URI를 생성하고 관리하는 것을 `컬렉션(Collection)`이라고 하며, 컬레션은 `/members`를 말한다.
2. 요청 데이터 처리

- 주문에서 결제완료 -> 배달시작 -> 배달완료
- 단순히 등록하는 것을 넘어서 프로세스의 상태가 변경되는 경우
- 예) POST /orders/{orderId}/start-delivery (배달시작) -> start-delivery처럼 URI에 동사가 있으면 이를 `컨트롤 URI`라고 한다.
3. 다른 메서드로 처리하기 애매한 경우

- `ajax`를 통해 데이터를 조회할 때 메시지 바디에 담고싶어서 POST를 사용할 수도 있다.
- 하지만 조회할 때는 왠만하면 `GET`을 사용하자.
    - 그 이유는 `캐싱!`

### PUT

- 리소스가 없으면 새로운 리소스를 생성하고, 리소스가 있으면 리소스를 완전히 대체한다. (덮어버린다.)
- POST와의 유일한 차이점은 PUT은 클라이언트가 리소스의 위치를 알고 URI를 딱 지정한다. ex) /members/100
    - 이처럼 클라이언트가 리소스 URI를 알고 관리하는 것을 `스토어(Store)`라고 하며, 스토어는 `/members`가 된다.
- 하지만 POST는 클라이언트가 리소스의 위치를 알지 못하고 자동으로 만들어준다. ex) /members
- 멱등하다.

```json
PUT /members/100 HTTP/1.1
Host: example.com
Content-type: application/json

{
    "name": "minsu",
    "age": 20
}
```

#### ❗ 잠깐 !

리소스를 완전히 대체한다는게 무슨 말일까?

만약 기존 데이터가 아래와 같다고 가정해보자.

```json
{
    "name": "minsu",
    "age": 20
}
```

여기서 PUT 메서드를 사용해서 `age`만 30으로 변경한다면 어떤 일이 벌어질까?

```json
PUT /members/100 HTTP/1.1
Host: example.com
Content-type: application/json

{
    "age": 30
}
```

age만 수정하면 되기 때문에 json 데이터는 age만 넘겨서 30으로 변경했다.

그러면 PUT의 완전히 대체된다는 특징 때문에 `name`이라는 필드는 없어지고 `age`만 남게됩니다.

만약 내가 회원가입을 하고 회원수정을 나이만 수정하고 싶은데 PUT 메서드를 사용하게 되면 나의 아이디, 비밀번호, 이메일... 이러한 중요한 정보들을 모두 잃을 수 있다.

### PATCH

내가 의도한대로 리소스의 부분만 수정되게 하려면 바로 `PATCH`를 사용하면 된다.

```json
PATCH /members/100 HTTP/1.1
Host: example.com
Content-type: application/json

{
    "age": 30
}
```

그러면 위와 같이 age만 30으로 변경해도 데이터는 `name`과 `age` 모두 그대로 남게된다.

- **PATCH는 멱등이 되도록 할 수 있고, 멱등이 안되게 할 수도 있다.**
- 예를 들어보자.

```json
{
    "age": 22
}
```

이것은 멱등이다.

하지만 아래는 멱등이 아니다.

```json
{
    "age": 22,
    "calc": add,
    "plusNumber": 1
}
```

이것은 계속 메서드를 수행할 때마다 `+1` 더하는 수행을 한다고 했을 때 age의 값이 변한다.

### DELETE

- 지정한 리소스를 삭제
- 멱등하다.

```json
DELETE /members/100 HTTP/1.1
Host: example.com
```

### 정리 (POST, PUT, PATCH)

- POST는 리소스의 위치를 알지 못해도 자동으로 생성해준다.
- PUT은 리소스의 위치를 알고 있고, 기존 리소스를 삭제하고 완전히 대체하기 때문에 중요한 데이터는 PUT을 사용하면 안된다.
- 중요한 데이터를 부분 수정하려면 PATCH를 사용한다.

<br>
<br>
<br>

## 클라이언트에서 서버로 데이터 전송

클라이언트에서 서버로 데이터를 전송하는데 크게 두 가지가 있다.

- 쿼리스트링을 통한 데이터 전송
    - GET
- 메시지 바디를 통한 데이터 전송
    - POST, PUT, PATCH

-> 자세한 내용은 [강의](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#)에서 `HTTP 메서드 활용편`을 보도록 하자.