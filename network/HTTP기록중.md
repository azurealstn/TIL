[##_Image|kage@OMVun/btrmHEop3jb/ncdr7zKWBRlBiopsTrfkXk/img.jpg|CDM|1.3|{"originWidth":768,"originHeight":500,"style":"alignCenter","caption":"인프런 - 김영한님의 HTTP","filename":"http2.jpg"}_##]

# HTTP (첫 번째 요약)

여기에 있는 내용은 모두 [인프런 - 김영한님](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#)의 강의를 보고 정리한 내용입니다.  
제일 좋은 공부 방법은 이런 요약을 보는 것이 아닌 직접 강의를 보고 이해해서 나의 것으로 만드는 게 중요하다고 생각합니다.

<br>
<br>
<br>

## IP(Internet Protocol)의 역할

- 지정한 IP 주소에 데이터를 전달한다.
- 통신 단위인 패킷을 전달한다.

## IP 패킷의 목적

![ip](https://user-images.githubusercontent.com/55525868/158522136-8eb1318f-d47e-46f0-8b37-785872441e0c.PNG)

- IP 패킷에는 출발지 IP와 목적지 IP가 있습니다.
- 먼저 출발지 IP인 클라이언트부터 IP 패킷을 보냅니다.
- 그렇게 많은 노드들을 통해 IP 패킷이 보내지면 결국에는 목적지 IP인 서버까지 도달하게 됩니다.
- 받은 IP 패킷을 통해 서버에서 다시 클라이언트로 서버패킷을 전달합니다.

> 패킷 : package와 bucket의 합친 말로, 네트워크상에서 전송하는 데이터의 형식화된 블록이다.
참고: https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%8C%A8%ED%82%B7

## IP 프로토콜의 한계

- 비연결성
    - 만약 패킷을 받을 상대가 인터넷이 끊겨도 즉, 서비스 불능 상태여도 패킷을 그대로 전송합니다.
- 비신뢰성
    - 패킷을 전송했는데 중간에 패킷이 사라지거나 패킷이 순서대로 오지 않은 경우
- 프로그램 구분
    - 한 IP로 여러 애플리케이션을 돌릴 경우

**이러한 IP 프로토콜의 한계를 TCP가 해결해줍니다.**

<br>
<br>
<br>

## 인터넷 프로토콜 4계층

![stack](https://user-images.githubusercontent.com/55525868/158523007-ce2b9ad7-e082-4fdf-8079-9fcfe0ddc7e0.PNG)

참고 : https://hahahoho5915.tistory.com/15

- 1계층 `네트워크 인터페이스 계층` : 물리적인 주소로 MAC을 사용하고 LAN, 패킷망 등에 사용됩니다.
- 2계층 `인터넷 계층` : 통신 노드간의 IP패킷을 전송하는 기능과 라우팅 기능을 담당합니다.
- 3계층 `전송 계층` : 통신 노드간의 연결을 제어하고, 신뢰성 있는 데이터 전송을 담당합니다.
- 4계층 `어플리케이션 계층` : TCP/UDP 기반의 응용 프로그램을 구현할 때 사용됩니다.

`IP`의 부족한 점을 인터넷 계층 위에 대신 채워줄 전송 계층이라는 `TCP`를 씌웁니다.

![tcp2](https://user-images.githubusercontent.com/55525868/158523906-c81513d4-06a9-4572-b2f2-77dd0f84252b.PNG)

1. 만약 펜팔친구에게 `잘 지내니`라는 메시지를 보낸다고 가정하자. 이 때 IP 패킷을 두 개로 나누어서 보냅니다. `잘` 패킷과 `지내니` 패킷

> IP는 순서가 보장되지 않기 때문에 `지내니 잘`로 메시지가 갈 수도 있습니다.

2. 메시지를 보낼 때 어플리케이션 계층인 `Socket 라이브러리`를 통해 데이터를 전송합니다.

3. 그리고나서 OS 계층에서 `IP 패킷`에다가 `TCP`를 씌웁니다.

4. LAN 카드를 통해 패킷을 서버로 전송합니다.

## TCP

- TCP는 IP 패킷 안에 TCP 정보가 들어갑니다.
- TCP에는 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 등의 정보가 들어있습니다.

## TCP 특징

-   TCP란 전송 제어 프로토콜(Transmissioni Control Protocol)입니다.
-   연결지향 - TCP 3 way handshake
-   데이터 전달 보증
    - 중간에 패킷이 누락되어도 알 수 있음
-   순서 보장
-   신뢰성 있는 프로토콜 -> 대부분 TCP를 사용합니다.

### TCP 3 way handshake

1.  클라이언트 -> 서버로 `SYN`이라는 메시지를 보내서 접속을 요청합니다.
2.  서버 -> 클라이언트로 `ACK`라는 메시지를 통해 접속 요청에 대한 응답을 해주고 다시 서버쪽에서 요청을 하기 위해 `SYN`을 보냅니다. 즉, 이때는 `SYN+ACK` 이렇게 메시지를 보냅니다.
3.  클라이언트 -> 서버로 서버에 대한 요청을 응답해주기 위한 `ACK` 메시지를 보냅니다.

위 세 과정을 하게 되면 클라이언트와 서버간에 신뢰할 수 있게 되어 연결을 할 수 있게 됩니다.  
이것을 **3 way handshake** 라고 합니다.

예를 들어, 클라이언트쪽에서 `SYN`을 보냈는데 서버쪽에서 `ACK`를 못받으면 문제가 있는 것으로 판별할 수 있습니다.

기존에 `IP 프로토콜`만 있을 때는 `비연결성`이기 때문에 클라이언트쪽에서 패킷을 보내도 정상적으로 데이터가 전송이 되었는지 누락이 되었는지 알 수 없었지만 `TCP 프로토콜`이 생기면서 이러한 점을 보완할 수 있습니다.
  
> 여기서 알아야 할 점은 3 way handshake는 물리적으로 서로 연결된 것이 아니라 논리적으로 연결된 것을 말합니다.
> 즉, "아, 서로 연결이 잘됐나 보다~" 하고 판단을 내린 가상 연결을 의미합니다.

<br>
<br>

### 데이터 전달 보증

1. 클라이언트에서 서버로 데이터를 전송합니다.
2. 서버에서 클라이언트로 데이터를 잘 받았다고 전송합니다.

위 과정이 이루어져야 신뢰성 있는 통신이 가능합니다.  
만약 데이터를 전송했는데 그에 대한 응답이 없으면 정상적으로 연결이 되지 않은 겁니다.

  

### 순서 보장

1. 클라이언트에서 서버로 패킷1, 패킷2, 패킷3 ... 순서로 전송합니다.
2. 만약 서버에서 패킷1, 패킷3, 패킷2 ... 순서로 받았다면 순서가 맞지 않으므로 서버에서 클라이언트로 다시 패킷2부터 보내라고 요청합니다. -> 순서가 보장됩니다.

이렇게 순서가 보장이 될 수 있는 이유는 TCP의 전송 제어, 검증 등의 정보 때문에 가능한 것입니다.  
그래서 TCP는 신뢰성 있는 프로토콜이라고도 불리는 겁니다.

  
  
  

## UDP

UDP는 TCP과 같은 전송 계층에 있습니다.

## UDP 특징

- 사용자 데이터그램 프로토콜 (User Datagram Protocol)
- 기능이 거의 없습니다.
- 연결지향 - TCP 3 way handshake X
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서를 보장하지 않지만 그 만큼 속도가 빠르다는 장점이 있습니다.

이는 즉, IP와 거의 같지만 여기에 PORT와 체크섬(검증)이 추가됩니다.  
위에서는 IP는 한 IP에 여러 애플리케이션이 돌아갈 경우에 패킷을 구분할 수가 없어서 한계점이라고 했습니다.  
만약 여기에 PORT가 추가되면 한 IP에 각각의 애플리케이션마다 패킷을 구분할 수가 있습니다.

<br>

결국 TCP와 UDP의 결정적 차이는 '속도' 입니다.  
TCP는 3 way handshake라는 과정을 거쳐야 하기 때문에 속도가 UDP보다 느릴 수 밖에 없습니다.   
UDP는 그런 과정이 없는 하얀 도화지이기 때문에 속도가 더 빠릅니다.

<br>
<br>
<br>

## PORT

만약 내 pc 에 여러 어플리케이션을 돌리고 있다고 가정해보자. (게임, 화상 통화, 웹 브라우저 요청 ...)  
이 경우에는 여러 서버랑 통신하게 됩니다.  
여기서 서버쪽에서 각각의 어플리케이션의 패킷들이 내 pc로 올텐데 이 때!! 패킷들이 게임 패킷인지, 화상통화 패킷인지, 웹 브라우저 응답 패킷인지 구분을 할 수가 없습니다.  
그래서 한 IP안에 여러 어플리케이션 패킷을 구분 지을 수 있도록 'PORT' 를 사용합니다.

<br>

즉, IP는 어떤 출발지와 목적지를 구분하기 위해 출발지 IP, 목적지 IP가 있고  
PORT는 한 IP 내에 여러 어플리케이션이 돌고 있을 때 각 패킷을 구분짓기 위해 사용합니다.

> 게임: 8000포트
> 화상 통화: 10000포트
> 웹 브라우저 요청: 8080포트

-   PORT는 0 ~ 65535 할당이 가능합니다.
-   0 ~ 1023 은 잘 알려진 포트이므로 사용하지 않는 것이 좋습니다.
    -   FTP : 20, 21
    -   TELNET : 23
    -   HTTP : 80
    -   HTTPS : 443

> IP와 PORT를 구분하는 예시
> 아파트가 있을 때 한 아파트는 IP,
> 한 아파트의 몇동, 몇호는 PORT
  
<br>

## DNS

내 PC와 상대 PC를 구분짓기 위해 출발지 IP와 목적지 IP 라는 것을 사용했었습니다.  
하지만 IP는 `100.100.100.1` 처럼 숫자로 되어 있기 때문에 외우기가 쉽지 않습니다.

<br>

그래서 사람들이 외우기 쉽게 하기 위해 IP에 이름을 짓습니다. 이것이 바로 `도메인명` 입니다.  
예를 들어 구글이면 구글 사이트가 만약 IP가 `123.456.673.2` 이렇게 되어 있으면 사람들이 굉장히 구글 사이트에 들어가기가 힘들 것입니다.  
하지만 구글 이라는 타이틀로 도메인을 설정하면 사람들이 쉽게 접근할 수 있겠죠. (ex. [www.google.com](http://www.google.com))

또 한 가지 `DNS 서버`를 사용하게 되면 다음과 같은 key, value 형태로 값이 저장하게 됩니다.

|도메인명|IP|
|:---:|:---:|
|google.com|123.456.673.2|

- 여기서 만약 구글의 IP가 변경된다고 해도 그대로 도메인명인 `google.com`을 사용하면 됩니다.
- 왜냐하면 value인 IP만 변경하면 되므로 도메인명은 그대로 사용하는 것이죠.
  
## 여기까지 정리해보기.

### IP (Internet Protocol address)

- IP는 각 컴퓨터의 주소이고, 역할은 상대 IP 주소로 데이터를 전송한다.
- 다만, IP는 비신뢰성이고, 비연결성이고, 순서가 없고, 프로그램 구분을 할 수가 없다.

### TCP (Transmission Control Protocol)

- 위 IP의 한계로 나온 것이 TCP 프로토콜
- TCP는 신뢰성 있고(데이터 전달 보장), 연결지향인 3 way handshake를 사용하고, 순서가 보장된다.
- 다만, 3 way handshake 통신으로 인해 속도가 느리다.

### UDP (User Datagram Protocol)

- TCP와 거의 반대로 기능이 거의 없고, 3 way handshake를 사용하지 않고, 순서를 보장하지 않고, 신뢰성이 없다.
- 다만, 3 way handshake를 사용하지 않아 TCP보다 속도가 빠르다.
- 또한 TCP와 다르게 사용자가 직접 커스터마이징할 수 있다.

### PORT

- 사용하는 어플리케이션을 구분하기 위해서 사용.

### DNS

- IP는 외우기 어렵고 변경되면 골치아픈데 그러한 문제를 해결해주는 것이 `DNS`이다.

<br>
<br>
<br>

## URI

- URI(Uniform Resource Identifier)는 로케이터(Locator), 이름(Name) 또는 둘 다 추가로 분류될 수 있습니다.

> URI는 통합 자원 식별자의 줄임말이다.
> 결론은 URI라는 개념은 어떤 형식이 있다기 보다는 특정 자원을 식별하는 문자열을 의미한다. 그래서 URL이 아니고 URN도 아니면 그냥 URI가 된다.
> 참고 : https://hanamon.kr/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EB%B3%B8-url-uri-urn-%EC%B0%A8%EC%9D%B4%EC%A0%90/
  
- URI 안에 URL과 URN이 있습니다.  
- `URL`은 `https://www.naver.com` 처럼 웹 브라우저에 주소 적는 것이 URL 입니다.
    - Locator, 리소스가 있는 위치 조정
- `URN`은 `urn:example:animal:ferret:nose` 처럼 주소처럼 이름을 부여하는 것이 URN 입니다. URN의 단점은 중간에 이름을 넣으면 찾기 매우 어렵습니다. -> 거의 URL만 사용.

URL과 URN의 차이점은 URL은 위치(Locator)로서 변할 수 있지만 이름(Name)은 변하지 않는다.

<br>

#### ❕ query string

쿼리 스트링은 URL에 파라미터 정보를 받기 위해서 사용합니다.  
즉, GET 방식에서 사용되고 `key=value` 형태로 되어있습니다.  
그리고 쿼리 스트링을 사용할 때는 `?`로 시작을 해서 여러 파라미터를 받기 위해서는 `&`로 구분합니다.

- ex) https://www.google.com/search?q=bye&sxsrf=APq
- 여기서 ? 뒤부터 쿼리 스트링이며,
- key는 q, sxsrf 그리고 value는 bye, Apq

그리고 쿼리 스트링에서 `string`인 이유는 파라미터 타입이 모두 문자열이기 때문입니다.

<br>
<br>
<br>

## 웹 브라우저 주소를 검색했을 때 무슨 일이 벌어질까?

면접에서도 나올만한 질문인 `https://www.naver.com` 이 주소를 쳤을 때 어떤 일이 벌어질까요?

<br>  

1. 가장 먼저 DNS서버를 조회합니다. ([www.naver.com](http://www.naver.com))

2. DNS를 조회해서 도메인명이 `www.naver.com`인 IP와 PORT를 찾아냅니다.

3. HTTP 요청 메시지를 생성하고 TCP/IP 패킷을 씌워서 이 패킷을 서버에 전달합니다. 이 패킷에는 IP, PORT 정보가 들어있고 전송데이터에는 HTTP 요청 메시지가 포함하고 있습니다.

4.  HTTP 요청 메시지가 포함된 요청 패킷을 `네이버 서버`로 보냅니다.

5.  서버는 받은 패킷 안에 있는 HTTP 요청 메시지를 해석해서 데이터를 찾습니다. (HTTP 메소드, 쿼리스트링, host 등등..)

6.  해석한 후에 네이버 서버에서 HTTP 응답 메시지를 생성해서 응답 패킷에 담아서 클라이언트로 보냅니다.

7.  클라이언트는 HTTP 응답 메시지를 보면 Body안에 데이터를 `Content-Type`에 따라 웹 브라우저에 렌더링되어 화면에 보여지게 됩니다.

### HTTP 요청 메시지

```
GET /search?name=minsu&lan=ko HTTP/1.1
Host: www.naver.com
```

> host란?
> IP를 가지고 있고 양방향 통신이 가능한 컴퓨터를 말한다.
> ex) www.google.com
> 참고: https://hihighlinux.tistory.com/73

### HTTP 응답 메시지

```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
    <body>...</body>
</html>
```

<br>
<br>
<br>

## HTTP

HTTP(HyperText Transfer Protocol)는 하이퍼 텍스트, 즉 문서 간에 정보를 주고 받을 수 있는 프로토콜입니다.  
현재는 모든 것을 HTTP 프로토콜에 담아서 전송하게 됩니다. (html, text, json, xml, image, 오디오, 영상 ...)  
또한 HTTP 에도 버전이 있는데 가장 많이 사용하는 버전이 `HTTP/1.1` 이 있습니다. 따라서 `HTTP/1.1` 을 공부하는 것이 중요합니다.

- TCP기반으로 사용되는 어플리케이션 계층에서 사용하는 HTTP 버전은 `HTTP/1.1`, `HTTP/2`를 사용하고,
- UDP기반은 `HTTP/3` 버전을 사용합니다.

  

## HTTP 특징

- 클라이언트 - 서버 구조
    - 클라이언트가 서버에 요청을 하고, 서버는 요청에 대한 응답하는 구조
- Stateless(무상태) Protocol, 비연결성
- HTTP 메시지를 통해 통신
- 단순하고, 확장 가능

### 무상태 (Stateless)

위에서 HTTP는 Stateless Protocol의 특징을 갖는다고 했습니다.

- Stateless란, 서버가 클라이언트의 상태를 보존하지 않는다는 뜻입니다.
- 반대로 Stateful은, 서버가 클라이언트의 상태를 보존한다는 뜻입니다.

![UI drawio (2)](https://user-images.githubusercontent.com/55525868/158754777-ff011bfe-c3f1-44e1-8c31-75c094ddc2ae.png)

#### Stateful인 경우

- 클라이언트와 서버1과 서로 통신하고 있을 때 에러가 발생하면 어떻게 될까?

서버1은 클라이언트의 상태를 유지합니다. 예를 들어, 어떤 상품을 100만원에 구매한다고 하면 그 정보를 서버1은 유지하고 있는 것입니다.

만약에 서버1이 다운된다면 서버1은 클라이언트의 정보를 다 잃게 됩니다.

그러면 클라이언트는 구매하려던 상품을 처음부터 다시 구매하기를 해야합니다.

#### Stateless인 경우

- 하지만 Stateless인 경우에는 어떻게 될까?

서버1은 클라이언트의 상태를 유지하지 않습니다. 예를 들어, 어떤 상품을 100만원에 구매한다고 하면 그 정보를 서버1은 유지하지 않습니다. 따라서 클라이언트는 애초에 필요한 데이터를 모두 넘겨야 합니다. ex)아이패드 신형을 네이버페이로 100만원에 구매하겠습니다.

만약에 서버1이 다운된다해도 클라이언트 입장에서는 전혀 문제가 없습니다.

그 이유는, 서버2라는 대체 서버가 존재하기 때문입니다. Stateful도 대체 서버가 존재하는데 왜 Stateless만 문제가 없을까요?

Stateless의 경우 클라이언트는 필요한 데이터를 모두 넘겨야 한다고 했습니다. 그래서 데이터 안에 필요한 정보가 다 들어있기때문에 다른 서버와 통신해도 전혀 문제가 발생하지 않는 것이죠.

> 그래서 Stateless는 서버를 scale-out, 무한히 확장가능한 것입니다.
  
### Stateless의 한계

하지만 모든 것을 Stateless하게 설계할 수는 없습니다.

예를 들어, 로그인이 대표적인 예입니다.

로그인을 했을 때 상태를 유지하지 않는다면 다른 페이지로 요청했을 때 또 로그인을 해야합니다.

그래서 이를 해결하기 위해 나온 것이 `쿠키와 세션`입니다.
  
또 한 가지의 단점은,

Stateless는 필요한 데이터를 모두 넘겨야하기 때문에 데이터를 많이 보냅니다.

> 결론은 애플리케이션을 설계할 때는 최대한 무상태로 설계하고, 어쩔 수 없는 경우에만 상태를 유지한다.

<br>

## 비연결성 (connectionless)

![UI drawio (3)](https://user-images.githubusercontent.com/55525868/158755016-ed57fa0d-338f-4d49-bb9f-7b2fcf43eb93.png)

### 연결성

비연결성에 대해 알아보기 전에 먼저 '연결성 모델'에 대해 알아보겠습니다.

1. 클라이언트A는 서버1과 통신합니다.
2. 클라이언트B도 서버1과 통신합니다.
3. 클라이언트C도 서버1과 통신하고 있을 때 클라이언트A와 클라이언트B는 서버1과 계속 연결을 유지하고 있습니다. (통신을 계속 하고 있다는 의미)

이 때 문제점은 클라이언트C와 서버1과 통신하고 있을 때 필요하지 않는 통신(클라이언트A, 클라이언트B)도 계속 유지하고 있기 때문에 서버1 입장에서는 자원을 계속 소비하게 됩니다.

클라이언트가 적을 때는 상관없지만 클라이언트가 갑자기 급증하게 된다면 서버에 과부하가 걸려서 서버가 다운될 것입니다.

---

### 비연결성

반면에 비연결성은 간단합니다.

1. 클라이언트A와 서버1과 통신하고 연결을 끊습니다.
2. 클라이언트B와 서버1과 통신하고 연결을 끊습니다.
3. 클라이언트C와 서버1과 통신하고 연결을 끊습니다.

각각의 클라이언트가 서버1과 통신하고 바로바로 연결을 끊기 때문에 낭비되는 서버 자원을 줄일 수 있습니다.

그래서 요청이 필요할 때마다 그때그때 연결해서 바로 끊는 형태로 됩니다.

### 결론

HTTP의 큰 장점인 비연결성은 클라이언트가 요청하고 서버가 응답하면 연결을 끊기 때문에 서버 자원을 효율적으로 사용할 수 있고, 특정 시간동안 수천명의 사용자가 서비스를 사용해도 실제로 동시에 요청하는 건수는 수십개 밖에 안되므로 비연결성 모델을 사용하는 것이 좋습니다.

### 비연결성의 단점

HTTP 통신은 대부분이 TCP/IP를 사용합니다. 하지만 TCP/IP는 바로 `3 way handshake`를 사용합니다. 이는 즉 신뢰성 있는 데이터 전달을 위해 **시간이 추가**된다는 의미입니다.

그리고 또 다른 단점은 많은 자원을 다시 다운로드해야 됩니다.

웹 브라우저를 요청하게 되면 html, css, js, image... 등등 필요한 자원을 다운로드하게 되는데 그러면 요청할 때마다 수많은 자원들을 다시 다운로드해야하는 단점이 있습니다.

- 하지만 지금은 HTTP 지속 연결(Persistent Connections)로 문제를 해결함.
- 그리고 HTTP/2, HTTP/3로 이러한 단점들이 많이 보완되었음.

### HTTP 지속 연결

자, HTTP는 TCP/IP 기반으로 돌아갑니다. 그리고 TCP/IP는 3-way-hankshake를 사용합니다. (이것만 기억하고 다음을 읽어보죠.)

HTTP는 문서 간에 정보를 주고받을 수 있는 프로토콜이라고 했습니다. (현재는 모든 정보를 HTTP를 통해서 주고받죠.)

(가정) HTTP를 통해 html 자원을 받고싶다면 시간이 얼마나 걸릴까요?

먼저 TCP/IP의 3-way-hankshake로 연결확인하고 html 요청/응답 확인하고 TCP/IP 연결을 종료합니다. 이게 하나의 리소스(html)를 다운받는데 일련의 과정입니다. 이 과정에 0.3초 걸린다고 가정해봅시다.
  
![UI drawio (4)](https://user-images.githubusercontent.com/55525868/158779319-e73b1507-6ba9-4756-9d91-f2157bc4f135.png)

그러면 만약에 필요한 리소스가 html, css ,js라고 한다면 `0.3 * 3 = 0.9초`가 걸립니다.

하지만 HTTP 지속 연결을 사용한다면 시간이 더 단축됩니다.

![UI drawio (5)](https://user-images.githubusercontent.com/55525868/158780043-5fc7ea7b-57c3-4d33-9ce6-62832b6578e9.png)

차이점은

HTTP 지속 연결을 사용하지 않는다면 매번 연결하고 종료해줘야 했지만

HTTP 지속 연결을 사용하면 한번 연결하고 리소스 요청/응답받고 한번 종료시키기 때문에 시간이 훨씬 단축됩니다.

### 💫 참고!!!

#### 서버개발자들은 반드시 Stateless를 꼭 기억하자

- 같은 시간에 발생하는 대용량 트래픽
- 이벤트가 생길 때 사용자가 급증할 때

**이를 해결하기 위해서는 어떻게든 머리를 짜서 반드시 Stateless하게 설계를 해야 합니다.**

> 간단한 해결법은 일단은 정적 페이지하나 생성해서 일단 그 페이지를 보게 한 다음에 이벤트 페이지로 들어가게 만드는 방법

## HTTP 메시지

![http](https://user-images.githubusercontent.com/55525868/144202391-d37c87e6-0bbf-44e7-8673-2b88628b601c.PNG)

(HTTP 메시지 구조)

### 시작 라인

-   HTTP 버전, HTTP 메소드(GET, POST ...)
-   HTTP 상태 코드

### 헤더

-   HTTP 전송에 필요한 모든 부가정보 (메타 데이터)
    -   메시지 바디의 내용, 크기, 요청 정보, 인증, 캐시 등등...
-   Content-Type, charset, Content-Length 등의 정보를 담습니다.

### 메시지 바디

-   실제 전송할 데이터
-   HTML 문서, 이미지, 영상 JSON 등등 byte로 표현할 수 있는 모든 데이터
-   클라이언트에서 요청할 때 POST 방식으로 데이터를 보낼 필요가 있는데 이 데이터를 메시지 바디에 담아서 보내게 됩니다.
